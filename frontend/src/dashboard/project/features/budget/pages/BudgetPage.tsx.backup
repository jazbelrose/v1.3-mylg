import React, {
  useState,
  useEffect,
  useRef,
  useMemo,
  useCallback,
  useLayoutEffect,
} from "react";
import { useNavigate, useParams, useLocation } from "react-router-dom";
import { AnimatePresence, motion } from "framer-motion";
import ConfirmModal from "../../components/ConfirmModal";
import * as ExcelJS from "exceljs";
import styles from "./BudgetPage.module.css";

import ProjectPageLayout from "./components/SingleProject/ProjectPageLayout";
import ProjectHeader from "./components/SingleProject/ProjectHeader";
import QuickLinksComponent from "./components/SingleProject/QuickLinksComponent";
import FileManagerComponent from "./components/SingleProject/FileManager";
import BudgetHeader from "./components/SingleProject/BudgetHeader";
import BudgetFileModal from "./components/SingleProject/BudgetFileModal";
import CreateLineItemModal from "./components/SingleProject/CreateLineItemModal";
import EventEditModal from "./components/SingleProject/EventEditModal";
import RevisionModal from "./components/SingleProject/RevisionModal";
import BudgetChart from "./components/SingleProject/BudgetChart";
import BudgetToolbar from "./components/SingleProject/BudgetToolbar";
import BudgetItemsTable from "./components/SingleProject/BudgetItemsTable";
import BudgetStateManager from "./components/SingleProject/BudgetStateManager";
import BudgetEventManager from "./components/SingleProject/BudgetEventManager";
import BudgetTableLogic from "./components/SingleProject/BudgetTableLogic";
import { BudgetProvider, useBudget } from "./components/SingleProject/BudgetDataProvider";
import { useData } from "../../app/contexts/DataProvider";
import { findProjectBySlug, slugify } from "../../utils/slug";
import {
  fetchBudgetHeaders,
  updateBudgetItem,
  fetchBudgetItems,
} from "../../utils/api";

const TABLE_HEADER_FOOTER = 110;
const TABLE_BOTTOM_MARGIN = 20;

// Inner component that uses the budget context
const BudgetPageContent = () => {
  const { projectSlug } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const {
    activeProject: initialActiveProject,
    projects,
    fetchProjectDetails,
    user,
    userId,
    setProjects,
    setSelectedProjects,
    updateTimelineEvents,
    isAdmin: isAdminCtx,
    isBuilder,
    isDesigner,
  } = useData();
  const isAdmin = !!isAdminCtx;
  const canEdit = isAdmin || isBuilder || isDesigner;
  const [activeProject, setActiveProject] = useState(initialActiveProject);
  const [filesOpen, setFilesOpen] = useState(false);
  const quickLinksRef = useRef(null);
  const tableRef = useRef(null);
  const [tableHeight, setTableHeight] = useState(0);
  const [saving, setSaving] = useState(false);
  
  // Budget data from context
  const { budgetHeader, budgetItems } = useBudget();

  // Simplified state for remaining functionality
  const [budgetData, setBudgetData] = useState([]);
  const [error, setError] = useState(null);
  const [revisions, setRevisions] = useState([]);
  const [areaGroups, setAreaGroups] = useState([]);
  const [invoiceGroups, setInvoiceGroups] = useState([]);
  const [clients, setClients] = useState([]);

  useLayoutEffect(() => {
    const updateTableHeight = () => {
      if (tableRef.current) {
        const top = tableRef.current.getBoundingClientRect().top;
        setTableHeight(window.innerHeight - top - TABLE_BOTTOM_MARGIN);
      }
    };

    updateTableHeight();
    window.addEventListener("resize", updateTableHeight);

    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(updateTableHeight);
      resizeObserver.observe(document.body);
    }

    return () => {
      window.removeEventListener("resize", updateTableHeight);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, []);

  useEffect(() => {
    if (!initialActiveProject) return;
    if (slugify(initialActiveProject.title) !== projectSlug) {
      const proj = findProjectBySlug(projects, projectSlug);
      if (proj) {
        fetchProjectDetails(proj.projectId);
      } else {
        navigate(`/dashboard/projects/${slugify(initialActiveProject.title)}`);
      }
    }
  }, [
    projectSlug,
    projects,
    initialActiveProject,
    navigate,
    fetchProjectDetails,
  ]);

  const handleBack = () => {
    navigate(`/dashboard/projects/${projectSlug}`);
  };

  const parseStatusToNumber = (statusString) => {
    if (statusString === undefined || statusString === null) {
      return 0;
    }
    const str =
      typeof statusString === "string" ? statusString : String(statusString);
    const num = parseFloat(str.replace("%", ""));
    return Number.isNaN(num) ? 0 : num;
  };

  const handleActiveProjectChange = (updatedProject) => {
    setActiveProject(updatedProject);
  };

  const handleProjectDeleted = (deletedProjectId) => {
    setProjects((prev) => prev.filter((p) => p.projectId !== deletedProjectId));
    setSelectedProjects((prev) =>
      prev.filter((p) => p.projectId !== deletedProjectId)
    );
    navigate("/dashboard/projects");
  };

  const handleBallparkChange = async (val) => {
    if (!activeProject?.projectId || !budgetHeader) return;
    try {
      await updateBudgetItem(activeProject.projectId, budgetHeader.budgetItemId, {
        headerBallPark: val,
        revision: budgetHeader.revision,
      });
      // Note: setBudgetHeader will be handled by the BudgetDataProvider
    } catch (err) {
      console.error('Error updating ballpark', err);
    }
  };

  const queueEventsUpdate = async (events) => {
    if (!activeProject?.projectId) return;
    try {
      setSaving(true);
      // Use the updateTimelineEvents from useData context
      await updateTimelineEvents(activeProject.projectId, events);
    } finally {
      setSaving(false);
    }
  };

  const eventsByLineItem = useMemo(() => {
    const map = {};
    if (Array.isArray(activeProject?.timelineEvents)) {
      activeProject.timelineEvents.forEach((ev) => {
        if (ev.budgetItemId) {
          if (!map[ev.budgetItemId]) map[ev.budgetItemId] = [];
          map[ev.budgetItemId].push(ev);
        }
      });
    }
    return map;
  }, [activeProject]);

  const eventDescOptions = useMemo(() => {
    const set = new Set();
    if (Array.isArray(activeProject?.timelineEvents)) {
      activeProject.timelineEvents.forEach((ev) => {
        const desc = (ev.description || '').trim().toUpperCase();
        if (desc) set.add(desc);
      });
    }
    return Array.from(set);
  }, [activeProject]);

  const computeGroupsAndClients = useCallback(
    (items, header) => {
      const aSet = new Set();
      const iSet = new Set();
      const cSet = new Set(Array.isArray(header?.clients) ? header.clients : []);
      items.forEach((it) => {
        if (it.areaGroup) aSet.add(String(it.areaGroup).trim().toUpperCase());
        if (it.invoiceGroup)
          iSet.add(String(it.invoiceGroup).trim().toUpperCase());
        if (it.client) cSet.add(it.client);
      });
      setAreaGroups(Array.from(aSet));
      setInvoiceGroups(Array.from(iSet));
      setClients(Array.from(cSet));
    },
    []
  );

  const handleUndo = async () => {
    if (undoStack.length === 0) return;
    const prev = undoStack[undoStack.length - 1];
    setUndoStack((s) => s.slice(0, s.length - 1));
    setRedoStack((s) => [
      ...s,
      {
        items: JSON.parse(JSON.stringify(budgetItems)),
        header: budgetHeader ? JSON.parse(JSON.stringify(budgetHeader)) : null,
      },
    ]);
    setBudgetItems(prev.items);
    setBudgetHeader(prev.header);
    computeGroupsAndClients(prev.items, prev.header);
    setSelectedRowKeys([]);
    await syncHeaderTotals(prev.items);
  };

  const handleRedo = async () => {
    if (redoStack.length === 0) return;
    const next = redoStack[redoStack.length - 1];
    setRedoStack((s) => s.slice(0, s.length - 1));
    setUndoStack((s) => [
      ...s,
      {
        items: JSON.parse(JSON.stringify(budgetItems)),
        header: budgetHeader ? JSON.parse(JSON.stringify(budgetHeader)) : null,
      },
    ]);
    setBudgetItems(next.items);
    setBudgetHeader(next.header);
    computeGroupsAndClients(next.items, next.header);
    setSelectedRowKeys([]);
    await syncHeaderTotals(next.items);
  };

  const getNextElementKey = useCallback(() => {
    const slug = slugify(activeProject?.title || '');
    let max = 0;
    budgetItems.forEach((it) => {
      if (typeof it.elementKey === 'string') {
        const match = it.elementKey.match(/-(\d+)$/);
        if (match) {
          const num = parseInt(match[1], 10);
          if (num > max) max = num;
        }
      }
    });
    const nextNum = String(max + 1).padStart(4, '0');
    return `${slug}-${nextNum}`;
  }, [activeProject?.title, budgetItems]);

  const getNextElementId = useCallback(
    (category) => {
      if (!category) return '';
      let max = 0;
      budgetItems.forEach((it) => {
        if (it.category === category && typeof it.elementId === 'string') {
          const match = it.elementId.match(/-(\d+)$/);
          if (match) {
            const num = parseInt(match[1], 10);
            if (num > max) max = num;
          }
        }
      });
      return `${category}-${String(max + 1).padStart(4, '0')}`;
    },
    [budgetItems]
  );

  const openCreateModal = () => {
    const nextKey = getNextElementKey();
    setNextElementKey(nextKey);
    setEditItem(null);
    setPrefillItem(null);
    setCreateModalOpen(true);
  };
  const openEditModal = (item) => {
    if (lockedLines.includes(item.budgetItemId)) return;
    setEditItem(item);
    setEditingLineId(item.budgetItemId);
    emitLineLock(item.budgetItemId);
    setPrefillItem(null);
    setCreateModalOpen(true);
  };
  const openEventModal = (item) => {
    if (lockedLines.includes(item.budgetItemId)) return;
    const evs = eventsByLineItem[item.budgetItemId] || [];
    setEventItem(item);
    setEventList(evs.map((ev) => ({ ...ev })));
    setEventModalOpen(true);
  };
  const openDuplicateModal = (item) => {
    const nextKey = getNextElementKey();
    const nextId = getNextElementId(item.category);
    const clone = { ...item, elementKey: nextKey };
    if (nextId) clone.elementId = nextId;
    delete clone.budgetItemId;
    setNextElementKey(nextKey);
    setPrefillItem(clone);
    setEditItem(null);
    setCreateModalOpen(true);
  };
  const closeCreateModal = () => {
    setCreateModalOpen(false);
    if (editingLineId) {
      emitLineUnlock(editingLineId);
    }
    setEditingLineId(null);
    setEditItem(null);
    setPrefillItem(null);
  };
  const closeEventModal = () => {
    setEventModalOpen(false);
    setEventItem(null);
    setEventList([]);
  };
  const handleSaveEvents = async (events) => {
    if (!activeProject?.projectId || !eventItem) {
      closeEventModal();
      return;
    }
    let others = Array.isArray(activeProject?.timelineEvents)
      ? activeProject.timelineEvents.filter((ev) => ev.budgetItemId !== eventItem.budgetItemId)
      : [];
    const withIds = events.map((ev) => ({
      id: ev.id || uuid(),
      date: ev.date,
      hours: ev.hours,
      description: ev.description || '',
      budgetItemId: eventItem.budgetItemId,
    }));
    const updated = [...others, ...withIds];
    try {
      await queueEventsUpdate(updated);
      emitTimelineUpdate(updated);
    } catch (err) {
      console.error('Error saving events', err);
    }
    closeEventModal();
  };

  const openDeleteModal = (ids) => {
    setDeleteTargets(ids);
    setIsConfirmingDelete(true);
  };

  const confirmDelete = async () => {
    if (!activeProject?.projectId || deleteTargets.length === 0) {
      setIsConfirmingDelete(false);
      setDeleteTargets([]);
      return;
    }
    pushHistory();
    try {
      await Promise.all(
        deleteTargets.map((id) => deleteBudgetItem(activeProject.projectId, id))
      );
      const updatedList = budgetItems.filter(
        (it) => !deleteTargets.includes(it.budgetItemId)
      );
      setBudgetItems(updatedList);
      setSelectedRowKeys((prev) =>
        prev.filter((key) => !deleteTargets.includes(key))
      );
      if (deleteTargets.includes(editItem?.budgetItemId)) {
        closeCreateModal();
      }
      if (Array.isArray(activeProject?.timelineEvents)) {
        const remainingEvents = activeProject.timelineEvents.filter(
          (ev) => !deleteTargets.includes(ev.budgetItemId)
        );
        if (remainingEvents.length !== activeProject.timelineEvents.length) {
          await queueEventsUpdate(remainingEvents);
          emitTimelineUpdate(remainingEvents);
        }
      }
      await syncHeaderTotals(updatedList);
      setLockedLines((prev) => prev.filter((id) => !deleteTargets.includes(id)));
    } catch (err) {
      console.error('Error deleting line items:', err);
    } finally {
      setIsConfirmingDelete(false);
      setDeleteTargets([]);
    }
  };

  const handleDuplicateSelected = async () => {
    if (!activeProject?.projectId || !budgetHeader || selectedRowKeys.length === 0)
      return;
    pushHistory();
    try {
      const toClone = budgetItems.filter((it) =>
        selectedRowKeys.includes(it.budgetItemId)
      );
      const tempItems = [...budgetItems];
      const clones = [];
      for (const item of toClone) {
        const slug = slugify(activeProject?.title || "");
        let maxKey = 0;
        tempItems.forEach((it) => {
          if (typeof it.elementKey === "string") {
            const match = it.elementKey.match(/-(\d+)$/);
            if (match) {
              const num = parseInt(match[1], 10);
              if (num > maxKey) maxKey = num;
            }
          }
        });
        const nextKey = `${slug}-${String(maxKey + 1).padStart(4, "0")}`;

        let maxId = 0;
        if (item.category) {
          tempItems.forEach((it) => {
            if (it.category === item.category && typeof it.elementId === "string") {
              const match = it.elementId.match(/-(\d+)$/);
              if (match) {
                const num = parseInt(match[1], 10);
                if (num > maxId) maxId = num;
              }
            }
          });
        }
        const nextId = item.category
          ? `${item.category}-${String(maxId + 1).padStart(4, "0")}`
          : "";

        const { budgetItemId, createdAt, updatedAt, ...rest } = item;
        const payload = {
          ...rest,
          elementKey: nextKey,
          revision: budgetHeader.revision,
          budgetItemId: `LINE-${uuid()}`,
        };
        if (nextId) payload.elementId = nextId;
        const newItem = await createBudgetItem(
          activeProject.projectId,
          budgetHeader.budgetId,
          payload
        );
        tempItems.push(newItem);
        clones.push(newItem);
      }
      const updated = [...budgetItems, ...clones];
      setBudgetItems(updated);
      setSelectedRowKeys([]);
      await syncHeaderTotals(updated);
    } catch (err) {
      console.error("Error duplicating line items:", err);
    }
  };

 
  const closeBudgetModal = () => setBudgetModalOpen(false);
  const openRevisionModal = () => setRevisionModalOpen(true);
  const closeRevisionModal = () => setRevisionModalOpen(false);

  const handleNewRevision = async (duplicate = false, fromRevision = null) => {
    if (!activeProject?.projectId || !budgetHeader) return;

    const targetRev = fromRevision != null ? fromRevision : budgetHeader.revision;

    let newRev;
    if (duplicate) {
      const base = Math.floor(targetRev);
      const decimals = revisions
        .filter((r) => Math.floor(r.revision) === base && r.revision !== base)
        .map((r) => parseInt(String(r.revision).split('.')[1] || '0', 10))
        .filter((n) => !Number.isNaN(n));
      const nextDec = decimals.length ? Math.max(...decimals) + 1 : 1;
      newRev = parseFloat(`${base}.${nextDec}`);
    } else {
      const bases = revisions.map((r) => Math.floor(r.revision));
      const nextBase = bases.length ? Math.max(...bases) + 1 : 1;
      newRev = nextBase;
    }

    while (revisions.some((r) => r.revision === newRev)) {
      if (duplicate) {
        const base = Math.floor(targetRev);
        const decimals = revisions
          .filter((r) => Math.floor(r.revision) === base && r.revision !== base)
          .map((r) => parseInt(String(r.revision).split('.')[1] || '0', 10))
          .filter((n) => !Number.isNaN(n));
        const nextDec = decimals.length ? Math.max(...decimals) + 1 : 1;
        newRev = parseFloat(`${base}.${nextDec}`);
      } else {
        newRev += 1;
      }
    }

    try {
      const sourceHeader =
        revisions.find((h) => h.revision === targetRev) || budgetHeader;
      const headerFields = duplicate
        ? {
            ...sourceHeader,
            revision: newRev,
            isHeader: true,
          }
        : {
            title: budgetHeader.title,
            startDate: budgetHeader.startDate,
            endDate: budgetHeader.endDate,
            clients: budgetHeader.clients,
            headerBallPark: 0,
            headerBudgetedTotalCost: 0,
            headerActualTotalCost: 0,
            headerEffectiveMarkup: 0,
            headerFinalTotalCost: 0,
            revision: newRev,
            isHeader: true,
          };
      delete headerFields.budgetItemId;
      delete headerFields.createdAt;
      delete headerFields.updatedAt;

      const newHeader = await createBudgetItem(
        activeProject.projectId,
        budgetHeader.budgetId,
        headerFields
      );

      let newItems = [];
      if (duplicate) {
        let items = budgetItems;
        if (sourceHeader.revision !== budgetHeader.revision) {
          items = await fetchBudgetItems(sourceHeader.budgetId, sourceHeader.revision);
        }
        if (items.length > 0) {
          newItems = await Promise.all(
            items.map((it) => {
              const { budgetItemId, createdAt, updatedAt, ...rest } = it;
              return createBudgetItem(activeProject.projectId, budgetHeader.budgetId, {
                ...rest,
                budgetItemId: `LINE-${uuid()}`,
                revision: newRev,
              });
            })
          );
        }
      }

      setBudgetHeader(newHeader);
      setBudgetItems(newItems);
      const revs = await fetchBudgetHeaders(activeProject.projectId);
      setRevisions(revs);
      emitBudgetUpdate();
    } catch (err) {
      console.error('Error creating new revision', err);
    }
  };

  const handleSwitchRevision = async (rev) => {
    if (!activeProject?.projectId) return;
    const header = revisions.find((h) => h.revision === rev);
    if (!header) return;
    try {
      const items = await fetchBudgetItems(header.budgetId, rev);
      setBudgetHeader(header);
      setBudgetItems(items);
      const aSet = new Set();
      const iSet = new Set();
      const cSet = new Set(Array.isArray(header.clients) ? header.clients : []);
      items.forEach((it) => {
        if (it.areaGroup) aSet.add(String(it.areaGroup).trim().toUpperCase());
        if (it.invoiceGroup)
          iSet.add(String(it.invoiceGroup).trim().toUpperCase());
        if (it.client) cSet.add(it.client);
      });
      setAreaGroups(Array.from(aSet));
      setInvoiceGroups(Array.from(iSet));
      setClients(Array.from(cSet));
    } catch (err) {
      console.error('Error switching revision', err);
    }
  };

  const handleDeleteRevision = async (rev) => {
    if (!activeProject?.projectId) return;
    const header = revisions.find((h) => h.revision === rev);
    if (!header) return;
    try {
      const items = await fetchBudgetItems(header.budgetId, rev);
      await Promise.all(
        items.map((it) => deleteBudgetItem(activeProject.projectId, it.budgetItemId))
      );
      await deleteBudgetItem(activeProject.projectId, header.budgetItemId);
      const updated = revisions.filter((h) => h.revision !== rev);
      setRevisions(updated);
      if (budgetHeader?.revision === rev) {
        const nextHeader = updated[0] || null;
        if (nextHeader) {
          const nextItems = await fetchBudgetItems(nextHeader.budgetId, nextHeader.revision);
          setBudgetHeader(nextHeader);
          setBudgetItems(nextItems);
        } else {
          setBudgetHeader(null);
          setBudgetItems([]);
        }
      }
      emitBudgetUpdate();
    } catch (err) {
      console.error('Error deleting revision', err);
    }
  };

  const handleSetClientRevision = async (rev) => {
    if (!activeProject?.projectId) return;
    try {
      await Promise.all(
        revisions.map((h) =>
          updateBudgetItem(activeProject.projectId, h.budgetItemId, {
            clientRevisionId: rev,
            revision: h.revision,
          })
        )
      );
      const updated = await fetchBudgetHeaders(activeProject.projectId);
      setRevisions(updated);
      // keep current editing revision but update its client flag
      setBudgetHeader((prev) => {
        if (!prev) return prev;
        const match = updated.find((h) => h.revision === prev.revision);
        return match ? { ...prev, clientRevisionId: match.clientRevisionId } : prev;
      });
      emitBudgetUpdate();
    } catch (err) {
      console.error('Error setting client revision', err);
    }
  };

  const calculateHeaderTotals = useCallback((items) => {
    let budgeted = 0;
    let final = 0;
    let actual = 0;
    items.forEach((it) => {
      const qty = parseFloat(it.quantity) || 0;
      const budget = parseFloat(it.itemBudgetedCost) || 0;
      const markup = parseFloat(it.itemMarkUp) || 0;
      const baseActual = it.itemActualCost ?? it.itemReconciledCost;
      const actualUnit = parseFloat(baseActual) || 0;

      budgeted += qty * budget;
      final += qty * budget * (1 + markup);
      actual += qty * actualUnit;
    });
    const effectiveMarkup = budgeted ? (final - budgeted) / budgeted : 0;
    return { budgeted, final, actual, effectiveMarkup };
  }, []);

  const syncHeaderTotals = useCallback(
    async (items) => {
      if (!activeProject?.projectId || !budgetHeader) return;
      const totals = calculateHeaderTotals(items);
      try {
        await updateBudgetItem(
          activeProject.projectId,
          budgetHeader.budgetItemId,
          {
            headerBudgetedTotalCost: totals.budgeted,
            headerFinalTotalCost: totals.final,
            headerActualTotalCost: totals.actual,
            headerEffectiveMarkup: totals.effectiveMarkup,
            revision: budgetHeader.revision,
          }
        );
        setBudgetHeader((prev) =>
          prev
            ? {
                ...prev,
                headerBudgetedTotalCost: totals.budgeted,
                headerFinalTotalCost: totals.final,
                headerActualTotalCost: totals.actual,
                headerEffectiveMarkup: totals.effectiveMarkup,
              }
            : prev
        );
        emitBudgetUpdate();
      } catch (err) {
        console.error('Error updating budget header:', err);
      }
    },
    [activeProject?.projectId, budgetHeader, calculateHeaderTotals, emitBudgetUpdate]
  );

  const groupFields = ["areaGroup", "invoiceGroup", "category"];

  const isDefined = (val) => {
    if (val === undefined || val === null) return false;
    const str = String(val).trim();
    if (!str) return false;
    const num = parseFloat(str.replace(/[$,]/g, ""));
    if (!Number.isNaN(num)) {
      return num !== 0;
    }
    return str !== "0";
  };

  const getActiveCostKey = useCallback(
    (item) => {
      if (isDefined(item.itemReconciledCost)) return "itemReconciledCost";
      if (isDefined(item.itemActualCost)) return "itemActualCost";
      return "itemBudgetedCost";
    },
    []
  );

  const baseColumnsOrder = [
    "elementKey",
    "elementId",
    "description",
    "quantity",
    "unit",

    "itemBudgetedCost",
    "itemActualCost",
    "itemReconciledCost",
    "itemMarkUp",
    "itemFinalCost",

    "paymentStatus",
  ];

  const mainColumnsOrder = useMemo(
    () =>
      groupBy !== "none" ? [groupBy, ...baseColumnsOrder] : baseColumnsOrder,
    [groupBy]
  );
  const columnHeaderMap = {
    elementKey: "Element Key",
    elementId: "Element ID",
    category: "Category",
    areaGroup: "Area Group",
    invoiceGroup: "Invoice Group",
    description: "Description",
    quantity: "Quantity",
    unit: "Unit",
    dates: "Dates",
    itemBudgetedCost: "Budgeted Cost",
    itemActualCost: "Actual Cost",
    itemReconciledCost: "Reconciled Cost",
    itemMarkUp: "Markup",
    itemFinalCost: "Final Cost",
    paymentStatus: "Payment Status",
  };

  const renderPaymentStatus = (status) => {
    const cleaned = (status || "")
      .replace(/[Â·.]+$/, "")
      .trim();
    const normalizedStatus = cleaned.toUpperCase();
    const colorClass =
      normalizedStatus === "PAID"
        ? styles.paid
        : normalizedStatus === "PARTIAL"
        ? styles.partial
        : styles.unpaid;
    const display =
      normalizedStatus === "PAID" || normalizedStatus === "PARTIAL"
        ? cleaned
        : "UNPAID";
    return (
      <span className={styles.paymentStatus}>
        {display}
        <span className={`${styles.statusDot} ${colorClass}`} />
      </span>
    );
  };
  const tableColumns = useMemo(() => {
    const hidden = [
      "projectId",
      "budgetItemId",
      "budgetId",
      "title",
      "startDate",
      "endDate",
      "itemCost",
    ];
    const safeBudgetItems = budgetItems.filter(Boolean);
    const available = safeBudgetItems.length
      ? Array.from(
          new Set([
            ...mainColumnsOrder,
            ...safeBudgetItems.flatMap((it) => Object.keys(it)),
          ])
        ).filter((key) => !hidden.includes(key))
      : mainColumnsOrder;
    const costKeys = [
      "itemBudgetedCost",
      "itemActualCost",
      "itemReconciledCost",
      "itemFinalCost",
    ];
    const allIds = safeBudgetItems.map((it) => it.budgetItemId);
    const cols = mainColumnsOrder
      .map((key) => {
        if (key === "dates") {
          return {
            title: columnHeaderMap[key],
            dataIndex: "dates",
            key: "dates",
          };
        }
        if (available.includes(key)) {
          const base = {
            title: columnHeaderMap[key] || key,
            dataIndex: key,
            key,
            sorter: () => 0,
            sortOrder: sortField === key ? sortOrder : null,
          };
          if (key === "elementKey") {
            base.title = (
              <span className={styles.elementKeyCell}>
                <input
                  type="checkbox"
                  checked={
                    allIds.length > 0 && selectedRowKeys.length === allIds.length
                  }
                  ref={(el) => {
                    if (el) {
                      el.indeterminate =
                        selectedRowKeys.length > 0 &&
                        selectedRowKeys.length < allIds.length;
                    }
                  }}
                  onChange={(e) => {
                    const { checked } = e.target;
                    setSelectedRowKeys(checked ? allIds : []);
                  }}
                  onClick={(e) => e.stopPropagation()}
                />
                <span style={{ marginLeft: "15px" }}>{columnHeaderMap[key]}</span>
              </span>
            );
            base.render = (value, record) => (
              <span className={styles.elementKeyCell}>
                <input
                  type="checkbox"
                  checked={selectedRowKeys.includes(record.budgetItemId)}
                  onChange={(e) => {
                    const { checked } = e.target;
                    setSelectedRowKeys((prev) => {
                      if (checked) {
                        return Array.from(new Set([...prev, record.budgetItemId]));
                      }
                      return prev.filter((k) => k !== record.budgetItemId);
                    });
                  }}
                  onClick={(e) => e.stopPropagation()}
                />
                <span style={{ marginLeft: "15px" }}>{value}</span>
              </span>
            );
          }
          if (key === "paymentStatus") {
            base.align = "right";
            base.render = renderPaymentStatus;
          } else if (key === "itemMarkUp") {
            base.render = (value) =>
              typeof value === "number" ? `${Math.round(value * 100)}%` : value;
          } else if (costKeys.includes(key)) {
            base.render = (value, record) => {
              if (!isDefined(value)) return "";
              if (key === "itemFinalCost") {
                return <span>{formatUSD(value)}</span>;
              }
              const activeKey = getActiveCostKey(record);
              const className = activeKey === key ? undefined : styles.dimmed;
              return <span className={className}>{formatUSD(value)}</span>;
            };
          }
          if (groupBy !== "none" && key === groupBy) {
            base.className = styles.groupColumn;
            const origRender = base.render;
            base.render = (value, record, index) => {
              const span = record[`${groupBy}RowSpan`];
              const children = origRender
                ? origRender(value, record, index)
                : value;
              return { children, props: { rowSpan: span } };
            };
          }
          return base;
        }
        return null;
      })
      .filter(Boolean);

    cols.push({
      title: "",
      key: "events",
      align: "center",
      render: (_v, record) => {
        const events = eventsByLineItem[record.budgetItemId] || [];
        const count = events.length;
        const tooltipContent = events.length
          ? (
              <div>
                {events.map((ev, i) => (
                  <div key={i}>
                    {new Date(ev.date).toLocaleDateString()} - {ev.hours} hrs
                    {ev.description ? ` - ${ev.description}` : ""}
                  </div>
                ))}
              </div>
            )
          : "No events";
        return (
          <AntTooltip title={tooltipContent} placement="top">
            <button
              className={styles.calendarButton}
              onClick={(e) => {
                e.stopPropagation();
                openEventModal(record);
              }}
              aria-label="Manage events"
            >
              <FontAwesomeIcon icon={faClock} />
              {count > 0 && <span className={styles.eventBadge}>{count}</span>}
            </button>
          </AntTooltip>
        );
      },
      width: 40,
    });
    cols.push({
      title: "",
      key: "actions",
      align: "center",
      render: (_value, record) => (
        <div className={styles.actionButtons}>
          <button
            className={styles.duplicateButton}
            onClick={(e) => {
              e.stopPropagation();
              openDuplicateModal(record);
            }}
            aria-label="Duplicate line item"
          >
            <FontAwesomeIcon icon={faClone} />
          </button>
          <button
            className={styles.deleteButton}
            onClick={(e) => {
              e.stopPropagation();
              openDeleteModal([record.budgetItemId]);
            }}
            aria-label="Delete line item"
          >
            <FontAwesomeIcon icon={faTrash} />
          </button>
        </div>
      ),
      width: 60,
    });
    return cols;
  }, [
    budgetItems,
    groupBy,
    mainColumnsOrder,
    sortField,
    sortOrder,
    selectedRowKeys,
    eventsByLineItem,
  ]);

  const tableData = useMemo(
    () =>
      budgetItems.map((item) => ({
        ...item,
        key: item.budgetItemId,
      })),
    [budgetItems]
  );

  const sortedTableData = useMemo(() => {
    const compareValues = (a, b) => {
      if (a === b) return 0;
      if (a === undefined || a === null) return -1;
      if (b === undefined || b === null) return 1;
      if (typeof a === "number" && typeof b === "number") {
        return a - b;
      }
      return String(a).localeCompare(String(b));
    };

    const data = tableData.slice();

    data.sort((a, b) => {
      if (groupBy !== "none") {
        const groupComp = compareValues(a[groupBy], b[groupBy]);
        if (groupComp !== 0) {
          // If sorting the group column itself allow descend/ascend
          if (sortField === groupBy && sortOrder === "descend") {
            return -groupComp;
          }
          return groupComp;
        }
      }

      if (sortField && sortField !== groupBy) {
        const fieldComp = compareValues(a[sortField], b[sortField]);
        return sortOrder === "descend" ? -fieldComp : fieldComp;
      }

      return 0;
    });

    return data;
  }, [tableData, groupBy, sortField, sortOrder]);

  const groupedTableData = useMemo(() => {
    if (groupBy === "none") {
      return sortedTableData.map((row) => ({ ...row }));
    }

    const result = [];
    let i = 0;

    while (i < sortedTableData.length) {
      const current = sortedTableData[i][groupBy];
      let j = i + 1;
      while (j < sortedTableData.length && sortedTableData[j][groupBy] === current) {
        j++;
      }

      const groupRows = sortedTableData.slice(i, j);
      const expandedCount = groupRows.filter((r) => expandedRowKeys.includes(r.key)).length;
      const span = groupRows.length + expandedCount;

      for (let k = i; k < j; k++) {
        const row = { ...sortedTableData[k] };
        row[`${groupBy}RowSpan`] = k === i ? span : 0;
        result.push(row);
      }

      i = j;
    }

    return result;
  }, [sortedTableData, groupBy, expandedRowKeys]);

  const detailOrder = [
    "paymentTerms",
    "paymentType",
    null,
    "vendor",
    "vendorInvoiceNumber",
    "poNumber",
    null,
    "client",
    "amountPaid",
    "balanceDue",
    null,
    "areaGroup",
    "invoiceGroup",
    "category",
  ];

  const expandedRowRender = useCallback(
    (record) => {
      const notes = record.notes;
      return (
        <table >
          <tbody>
            {(record.startDate || record.endDate) && (
              <tr key="dates">
                <td style={{ fontWeight: "bold", paddingRight: "8px" }}>Dates</td>
                <td style={{ textAlign: "right" }}>
                  {`${record.startDate || ""}${
                    record.endDate ? ` - ${record.endDate}` : ""
                  }`}
                </td>
              </tr>
            )}
            {detailOrder.map((key, idx) =>
              key === null ? (
                <tr key={`hr-${idx}`}>
                  <td colSpan={2}>
                    <hr style={{ margin: "8px 0", borderColor: "#444" }} />
                  </td>
                </tr>
              ) : (
                <tr key={key}>
                  <td style={{ fontWeight: "bold", paddingRight: "8px" }}>
                    {beautifyLabel(key)}
                  </td>
                  <td style={{ textAlign: "right" }}>{String(record[key] ?? "")}</td>
                </tr>
              )
            )}
            <tr key="notes-divider">
              <td colSpan={2}>
                <hr style={{ margin: "8px 0", borderColor: "#444" }} />
              </td>
            </tr>
            <tr key="notes">
              <td style={{ fontWeight: "bold", paddingRight: "8px" }}>Notes</td>
              <td
                style={{
                  whiteSpace: "pre-wrap",
                  lineHeight: 3,
                  color: notes ? "inherit" : "#888",
                  textAlign: "right",
                }}
              >
                {notes || "No notes available"}
              </td>
            </tr>
          </tbody>
        </table>
      );
    },
    [beautifyLabel]
  );

  const refresh = useCallback(async () => {
    if (!activeProject?.projectId) return;
    try {
      const revs = await fetchBudgetHeaders(activeProject.projectId);
      setRevisions(revs);
      const header =
        revs.find((h) => h.revision === h.clientRevisionId) || revs[0] || null;
      if (header) {
        setBudgetHeader(header);
        if (header.budgetId) {
          const items = await fetchBudgetItems(header.budgetId, header.revision);
          setBudgetItems(items);
          computeGroupsAndClients(items, header);
        }
      } else {
        setBudgetHeader(null);
        setClients([]);
      }
    } catch (err) {
      console.error("Error fetching budget header", err);
    }
  }, [activeProject?.projectId, computeGroupsAndClients]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  useEffect(() => {
    if (!ws) return;
    const handleMessage = async (event) => {
      try {
        const data = JSON.parse(event.data);
        if (
          data.action === 'lineLocked' &&
          data.projectId === activeProject?.projectId &&
          data.revision === budgetHeader?.revision
        ) {
          if (data.senderId === userId) return;
          setLockedLines((prev) => (prev.includes(data.lineId) ? prev : [...prev, data.lineId]));
        } else if (
          data.action === 'lineUnlocked' &&
          data.projectId === activeProject?.projectId &&
          data.revision === budgetHeader?.revision
        ) {
          if (data.senderId === userId) return;
          setLockedLines((prev) => prev.filter((id) => id !== data.lineId));
        } else if (
          data.action === 'budgetUpdated' &&
          data.projectId === activeProject?.projectId
        ) {
          if (data.senderId === userId) return;
          await refresh();
        } else {
          console.log('[BudgetPage] Ignoring websocket message', data);
        }
      } catch {
        // ignore parse errors
      }
    };
    ws.addEventListener('message', handleMessage);
    return () => ws.removeEventListener('message', handleMessage);
  }, [ws, activeProject?.projectId, budgetHeader?.revision, userId, refresh]);

  useEffect(() => {
    return () => {
      if (editingLineId) {
        emitLineUnlock(editingLineId);
      }
    };
  }, [editingLineId, emitLineUnlock]);

  const parseFile = async (file) => {
    if (!file) return;
    try {
      const data = await file.arrayBuffer();
      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.load(data);
      
      const worksheet = workbook.worksheets[0];
      const json = [];
      
      // Convert worksheet to JSON starting from row 12 (index 11)
      worksheet.eachRow((row, rowNumber) => {
        if (rowNumber >= 12) { // Skip first 11 rows
          const rowData = [];
          row.eachCell((cell, colNumber) => {
            rowData[colNumber - 1] = cell.value || "";
          });
          json.push(rowData);
        }
      });
      
      const [headers, ...rows] = json;
      const idxCategory = headers.findIndex(
        (h) => /element description/i.test(h) || /category/i.test(h)
      );
      const idxAmount = headers.findIndex(
        (h) =>
          /final total/i.test(h) || /amount/i.test(h) || /value|cost/i.test(h)
      );
      if (idxCategory < 0 || idxAmount < 0) {
        throw new Error(
          'Could not find "Element Description" (or "Category") and "Final Total" (or "Amount") columns.'
        );
      }
      const formatted = rows
        .map((row) => ({
          category: row[idxCategory],
          amount: parseFloat(row[idxAmount]) || 0,
        }))
        .filter((r) => r.category && r.amount > 0);

      setBudgetData(formatted);
      setError(null);
    } catch (err) {
      console.error(err);
      setError(
        'Failed to parse Excel file. Ensure it includes headers like "Element Description" and "Final Total" at row 12.'
      );
    }
  };


  const handleTableChange = (_pagination, _filters, sorter) => {
    const s = Array.isArray(sorter) ? sorter[0] : sorter;
    if (s && s.order) {
      setSortField(s.columnKey);
      setSortOrder(s.order);
    } else {
      setSortField(null);
      setSortOrder(null);
    }
  };


  const handleCreateLineItem = async (data, isAutoSave = false) => {
    if (data.budgetItemId) {
      return await handleEditLineItem(data, isAutoSave);
    }
    if (!activeProject?.projectId || !budgetHeader?.budgetId) return;
    if (!isAutoSave) {
      // Close the modal immediately so the UI feels responsive
      closeCreateModal();
    }
    pushHistory();
    try {
      const normalized = {
        ...data,
        areaGroup: data.areaGroup ? data.areaGroup.trim().toUpperCase() : '',
        invoiceGroup: data.invoiceGroup
          ? data.invoiceGroup.trim().toUpperCase()
          : '',
        description: data.description ? data.description.trim().toUpperCase() : '',
      };
      const clientName = normalized.client ? normalized.client.trim() : '';
      const item = await createBudgetItem(
        activeProject.projectId,
        budgetHeader.budgetId,
        { ...normalized, budgetItemId: `LINE-${uuid()}`, revision: budgetHeader.revision }
      );
      if (!item) {
        return;
      }
      const updated = [...budgetItems, item];
      setBudgetItems(updated);
      if (normalized.areaGroup) {
        setAreaGroups((prev) =>
          Array.from(new Set([...prev, normalized.areaGroup]))
        );
      }
      if (normalized.invoiceGroup) {
        setInvoiceGroups((prev) =>
          Array.from(new Set([...prev, normalized.invoiceGroup]))
        );
      }
      if (clientName && !clients.includes(clientName)) {
        const newClients = [...clients, clientName];
        try {
          await updateBudgetItem(
            activeProject.projectId,
            budgetHeader.budgetItemId,
            { clients: newClients, revision: budgetHeader.revision }
          );

          setBudgetHeader((prev) => (prev ? { ...prev, clients: newClients } : prev));
        } catch (err) {
          console.error('Error updating clients list', err);
        }
        setClients(newClients);
      }
      await syncHeaderTotals(updated);
      
      return { budgetItemId: item.budgetItemId };
    } catch (err) {
      console.error('Error creating line item:', err);
    }
    return null;
  };

  const handleEditLineItem = async (data, isAutoSave = false) => {
    if (!activeProject?.projectId || !data.budgetItemId) return;
    if (!isAutoSave) {
      // Close the modal immediately so the user doesn't wait for the request
      closeCreateModal();
    }
    pushHistory();
    try {
      const normalized = {
        ...data,
        areaGroup: data.areaGroup ? data.areaGroup.trim().toUpperCase() : '',
        invoiceGroup: data.invoiceGroup ? data.invoiceGroup.trim().toUpperCase() : '',
        description: data.description ? data.description.trim().toUpperCase() : '',
      };
      const updatedItem = await updateBudgetItem(
        activeProject.projectId,
        data.budgetItemId,
        { ...normalized, revision: budgetHeader.revision }
      );
      const updatedList = budgetItems.map((it) =>
        it.budgetItemId === updatedItem.budgetItemId ? updatedItem : it
      );
      setBudgetItems(updatedList);
      if (normalized.areaGroup && !areaGroups.includes(normalized.areaGroup)) {
        setAreaGroups((prev) => Array.from(new Set([...prev, normalized.areaGroup])));
      }
      if (normalized.invoiceGroup && !invoiceGroups.includes(normalized.invoiceGroup)) {
        setInvoiceGroups((prev) => Array.from(new Set([...prev, normalized.invoiceGroup])));
      }
      const clientName = normalized.client ? normalized.client.trim() : '';
      if (clientName && !clients.includes(clientName)) {
        const newClients = [...clients, clientName];
        try {
          await updateBudgetItem(
            activeProject.projectId,
            budgetHeader.budgetItemId,
            { clients: newClients, revision: budgetHeader.revision }
          );
          setBudgetHeader((prev) => (prev ? { ...prev, clients: newClients } : prev));
        } catch (err) {
          console.error('Error updating clients list', err);
        }
        setClients(newClients);
      }
      await syncHeaderTotals(updatedList);
      return { budgetItemId: updatedItem.budgetItemId };
    } catch (err) {
      console.error('Error updating line item:', err);
    }
    return null;
  };

  if (!isAdmin) {
    return <div>Access Denied</div>;
  }

  return (
  <>
      <style>{`
        :where(.ant-table-wrapper) .ant-table {
          font-size: 11px !important;
        }
      `}</style>
      <ProjectPageLayout
      projectId={activeProject?.projectId}
      header={
        <ProjectHeader
          activeProject={activeProject}
          parseStatusToNumber={parseStatusToNumber}
          userId={userId}
          onProjectDeleted={handleProjectDeleted}
          showWelcomeScreen={handleBack}
          onActiveProjectChange={handleActiveProjectChange}
          onOpenFiles={() => setFilesOpen(true)}
          onOpenQuickLinks={() => quickLinksRef.current?.openModal()}
        />
      }
    >
      {saving && (
        <div style={{ color: '#FA3356', marginBottom: '10px' }}>Saving...</div>
      )}
    <AnimatePresence mode="wait">
      <motion.div
        key={location.pathname}
        initial={{ x: 100, opacity: 0 }}
        animate={{ x: 0, opacity: 1 }}
        exit={{ x: -100, opacity: 0 }}
        transition={{ duration: 0.3 }}
      >
        <div className="budget-layout">
    <QuickLinksComponent ref={quickLinksRef} hideTrigger={true} />
      <FileManagerComponent
        isOpen={filesOpen}
        onRequestClose={() => setFilesOpen(false)}
        showTrigger={false}
        folder="uploads"
      />
      <BudgetHeader
        activeProject={activeProject}
        budgetHeader={budgetHeader}
        budgetItems={budgetItems}
        groupBy={groupBy}
        setGroupBy={setGroupBy}
        onOpenRevisionModal={openRevisionModal}
        onBallparkChange={handleBallparkChange}
      />
      <BudgetFileModal
        isOpen={isBudgetModalOpen}
        onRequestClose={closeBudgetModal}
        onFileSelected={parseFile}
      />
      <RevisionModal
        isOpen={isRevisionModalOpen}
        onRequestClose={closeRevisionModal}
        revisions={revisions}
        activeRevision={budgetHeader?.revision}
        onSwitch={handleSwitchRevision}
        onDuplicate={(rev) => handleNewRevision(true, rev)}
        onCreateNew={() => handleNewRevision(false)}
        onDelete={(rev) => handleDeleteRevision(rev.revision)}
        onSetClient={(rev) => handleSetClientRevision(rev)}
        isAdmin={canEdit}
        activeProject={activeProject}
      />
      <CreateLineItemModal
        isOpen={isCreateModalOpen}
        onRequestClose={closeCreateModal}
        onSubmit={(d, isAutoSave) =>
          editItem
            ? handleEditLineItem(d, isAutoSave)
            : handleCreateLineItem(d, isAutoSave)
        }
        defaultElementKey={nextElementKey}
        budgetItems={budgetItems}
        areaGroupOptions={areaGroups}
        invoiceGroupOptions={invoiceGroups}
        clientOptions={clients}
        defaultStartDate={budgetHeader?.startDate || ''}
        defaultEndDate={budgetHeader?.endDate || ''}
        initialData={prefillItem || editItem}
        title={editItem ? 'Edit Item' : 'Create Line Item'}
        revision={budgetHeader?.revision || 1}
      />
      <EventEditModal
        isOpen={isEventModalOpen}
        onRequestClose={closeEventModal}
        events={eventList}
        defaultDate={budgetHeader?.startDate || ''}
        defaultDescription={eventItem?.description || ''}
        descOptions={eventDescOptions}
        onSubmit={handleSaveEvents}
      />
      <ConfirmModal
        isOpen={isConfirmingDelete}
        onRequestClose={() => setIsConfirmingDelete(false)}
        onConfirm={confirmDelete}
        message="Delete selected line item(s)?"
        className={{
          base: styles.modalContent,
          afterOpen: styles.modalContentAfterOpen,
          beforeClose: styles.modalContentBeforeClose,
        }}
        overlayClassName={{
          base: styles.modalOverlay,
          afterOpen: styles.modalOverlayAfterOpen,
          beforeClose: styles.modalOverlayBeforeClose,
        }}
      />
      <div style={{ padding: "0 20px" }}>
        <div>
          {error && (
            <div style={{ marginTop: "10px", color: "#ff6b6b" }}>
              Error: {error}
            </div>
          )}
          {budgetData.length > 0 && <BudgetChart data={budgetData} />}
          <div
            style={{
              width: "100%",
              marginTop: "10px",
              display: "flex",
              flexDirection: "column",
              alignItems: "flex-start",
            }}
          >
            <BudgetToolbar
              groupBy={groupBy}
              onGroupChange={(val) => setGroupBy(val as string)}
              selectedRowKeys={selectedRowKeys}
              handleDuplicateSelected={handleDuplicateSelected}
              openDeleteModal={openDeleteModal}
              undoStackLength={undoStack.length}
              redoStackLength={redoStack.length}
              handleUndo={handleUndo}
              handleRedo={handleRedo}
              openCreateModal={openCreateModal}
            />
            <BudgetItemsTable
              dataSource={budgetItems.length > 0 ? groupedTableData : []}
              columns={tableColumns}
              groupBy={groupBy}
              selectedRowKeys={selectedRowKeys}
              lockedLines={lockedLines}
              handleTableChange={handleTableChange}
              openEditModal={openEditModal}
              openDeleteModal={openDeleteModal}
              expandedRowRender={expandedRowRender}
              expandedRowKeys={expandedRowKeys}
              setExpandedRowKeys={setExpandedRowKeys}
              tableRef={tableRef}
              tableHeight={tableHeight}
              pageSize={pageSize}
              currentPage={currentPage}
              setCurrentPage={setCurrentPage}
              setPageSize={setPageSize}
            />
          </div>
        </div>
      </div>
    </div>
    </motion.div>
  </AnimatePresence>
</ProjectPageLayout>
</>
  );
};

export default BudgetPage;

# ADR-003: Centralized CORS Configuration via Shared Layer Environment

- **Status**: Accepted
- **Date**: 2025-09-15
- **Owner**: Platform Engineering
- **Stakeholders**: API Gateway Services, Shared Layer Maintainers, Frontend Developers
- **Related PRs**:
  - [PR TBD](https://github.com/jazbelrose/v1.2-mylg/pull/ZZZZ)

## Context
Each backend service currently defines its own CORS settings inside individual Serverless configuration files, leading to
inconsistent allowed-origin lists and duplicated environment variables. Rolling out a new domain or staging host requires
editing every service, increasing risk of drift and accidental production exposure. The shared Lambda layer already provides
CORS helper utilities, but we lack a single source of truth for origin allowlists.

## Decision
Centralize all CORS configuration in the shared layer by relying on two environment variables exported through
`serverless.common.yml`:

1. `ALLOWED_ORIGINS` – A comma-delimited list of exact origins that should receive `Access-Control-Allow-Origin` responses.
2. `CORS_WILDCARD_HOSTS` – A comma-delimited list of host patterns (`*.mylg.app`, `*.mylg.dev`) that the helper interprets with
   wildcard matching for preview builds and ephemeral environments.

All services will consume the shared layer helper `resolveCorsOrigin(event)` which reads the environment variables, applies the
matching logic (exact first, then wildcard), and returns CORS headers or rejects the request. Service-specific overrides are
removed in favor of centrally managed values defined per stage.

## Alternatives Considered
- **Service-local environment variables** – Discarded because they require manual synchronization and increase the risk of
  forgetting to update a service during domain changes.
- **API Gateway default wildcard (`*`)** – Discarded because it violates security requirements by allowing credentialed requests
  from untrusted origins.
- **Secrets Manager configuration** – Discarded as overkill; secrets rotation is unnecessary for public origin lists and would add
  latency to cold starts.

## Pros
- Guarantees consistent CORS enforcement across HTTP and WebSocket services without copy/paste configuration.
- Stage-specific overrides can be applied once in `serverless.common.yml`, reducing deployment toil.
- Wildcard host support enables ephemeral preview environments while maintaining strict production allowlists.
- Simplifies documentation and onboarding because developers reference one place for allowed origins.

## Cons
- A misconfigured shared variable propagates immediately to every service, increasing blast radius for mistakes.
- Changes to the allowlist require redeploying services that consume the shared layer to pick up new environment values.
- Wildcard parsing logic must be carefully tested to avoid unexpected matches or regex injection issues.

## Operations / Telemetry
- Extend the shared CORS helper to emit a structured log entry (`cors_decision`) containing the request origin, match result, and
  reason whenever an origin is rejected.
- Publish a custom metric (`CorsRejectionCount`) per stage to CloudWatch so Ops can detect spikes when a new domain launches.
- Add synthetic health checks that execute OPTIONS requests from representative origins to verify header responses post-deploy.
- Include the resolved origin in API tracing spans (e.g., X-Ray annotations) to correlate user reports with infrastructure data.

## Implementation Plan
1. Update `serverless.common.yml` to define `ALLOWED_ORIGINS` and `CORS_WILDCARD_HOSTS` for each stage and surface them to all
   services via the shared layer exports.
2. Refactor the shared CORS utility to parse the comma-delimited values once and cache the compiled matchers across invocations.
3. Remove per-service CORS env variables and wire HTTP/WebSocket handlers to use the shared helper for header computation.
4. Add integration tests validating that known good/bad origins return the expected headers using the centralized config.
5. Document the process for updating origin lists and include change-management steps in the deployment runbook.

## Follow-Up Questions
- Should we back the environment variables with SSM Parameter Store for audit trails and stage-specific overrides managed via IaC?
- Do we need a tooling command to preview how a given origin maps to the allowlist for faster troubleshooting?

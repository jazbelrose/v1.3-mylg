# ADR-002: Direct Message Conversation Identifier Format

- **Status**: Accepted
- **Date**: 2025-09-15
- **Owner**: Product Messaging Team
- **Stakeholders**: Messaging Service, WebSocket Gateway, Frontend Inbox
- **Related PRs**:
  - [PR TBD](https://github.com/jazbelrose/v1.2-mylg/pull/YYYY)

## Context
Direct messages currently allow multiple divergent identifiers (database PKs, composite keys, and WebSocket channels) which makes
it hard to reconcile notifications, unread counts, and idempotent message storage. We need a single canonical conversation ID for
a pair of users that is deterministic, sortable, and portable across storage layers (DynamoDB, Redis, client caches).

## Decision
Adopt the format `dm#<lowerUserId>___<higherUserId>` for all two-party direct message threads. Implementation specifics:

1. Collect both user IDs, cast them to strings, and sort lexicographically. The first value becomes `<lowerUserId>` and the
   second becomes `<higherUserId>`.
2. Join the two parts using the delimiter string `___` (three underscores) and prefix the composite with `dm#`.
3. Use the resulting identifier as the partition key for DynamoDB DM tables, the WebSocket subscription identifier, and the
   inbox cache key on the frontend.
4. Store participant metadata separately if needed, but never rely on array order in payloads; the ID encodes the ordering rule.

## Alternatives Considered
- **Database-generated UUIDs** – Discarded because they cannot be reconstructed deterministically on clients, complicating
  optimistic rendering and duplicate detection.
- **Hashing both user IDs** – Discarded because hashes are opaque during debugging and add collision risk without strong
  hashing discipline.
- **User-order-dependent IDs** – Discarded because they require clients to know who initiated the conversation, causing duplicate
  threads when both participants start a DM.

## Pros
- Deterministic ID guarantees that the same pair of users always maps to the same conversation, preventing duplicates.
- Prefixed namespace (`dm#`) prevents collisions with future thread types (projects, groups) that may share persistence tables.
- IDs remain human-inspectable for debugging while staying URL-safe and storage-friendly.
- Sorting logic is trivial to replicate across backend languages and frontend TypeScript.

## Cons
- Format only supports two participants; group chat IDs will need a separate strategy to avoid overly long concatenations.
- Lexicographic sorting requires consistent normalization (e.g., lowercasing UUID strings) or else mismatches could occur.
- Existing records that stored unsorted pairs must be migrated, requiring data backfills and update scripts.

## Operations / Telemetry
- Emit a metric (`DuplicateDmIdDetected`) when a write observes an existing conversation with reversed participant order to
  measure migration completeness.
- Log the generated conversation ID alongside message write operations to ease incident forensics and cross-layer tracing.
- Add integration tests in the messaging CI pipeline that validate round-trip ID generation across languages (Node.js layer and
  any auxiliary services) to catch delimiter or sorting regressions.
- Update data quality dashboards to alert if a conversation ID lacks exactly two user IDs when split on `___`.

## Implementation Plan
1. Add shared-layer helper `buildDmConversationId(userA, userB)` used by HTTP APIs, WebSocket handlers, and background workers.
2. Backfill existing DynamoDB and cache records to rename legacy keys into the new format, logging before/after values.
3. Update frontend state managers to derive DM IDs via the same helper and migrate persisted cache entries.
4. Document the ordering rule in API schemas and publish test fixtures for contract testing with partner teams.

## Follow-Up Questions
- Should we reserve additional prefixes (`dm_group#`, `dm_system#`) now to avoid future breaking changes?
- Do we need a scheduled audit job to flag any DM thread where the stored participants do not match the ID encoding?

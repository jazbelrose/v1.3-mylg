# ADR-001: CDN File URL Strategy

- **Status**: Accepted
- **Date**: 2025-09-15
- **Owner**: Platform Engineering
- **Stakeholders**: Backend Services, Frontend Web, Infrastructure/DevOps
- **Related PRs**:
  - [PR TBD](https://github.com/jazbelrose/v1.2-mylg/pull/XXXX)

## Context
The application currently serves user-generated files and static assets from multiple entry points, mixing direct Amazon S3 object
URLs with legacy CloudFront links. That fragmentation makes cache invalidation harder, complicates URL signing, and creates
inconsistent security postures between public and private assets. We need a predictable CDN URL pattern that works for both
unsigned (public) assets and signed (authenticated) downloads while letting clients compose paths deterministically.

## Decision
We will standardize on a single CloudFront distribution (base URL `https://cdn.mylg.app`) for all externally shared files.

1. **Public objects** will be published under `https://cdn.mylg.app/public/...` and will not require CloudFront signed URLs.
2. **Restricted objects** will be exposed under `https://cdn.mylg.app/secure/...` and will require signed URLs generated with the
   CloudFront key pair managed by the shared layer utilities.
3. Backend services are responsible for generating deterministic paths of the form
   `/{visibility}/{tenantId}/{entity}/{objectKey}`, where `visibility` is either `public` or `secure`.
4. Upload flows will continue to write to S3 buckets, but all persisted metadata will store the canonical CloudFront path
   (not raw S3 URLs) so that clients always request assets through the CDN.

The shared layer will surface helpers for generating signed URLs (`secure`) and plain paths (`public`) so each service can adopt
this convention without duplicating signing logic.

## Alternatives Considered
- **Keep mixing S3 and CDN URLs** – Discarded because it perpetuates cache fragmentation and creates inconsistent client code.
- **Multiple CloudFront distributions** – Discarded because it introduces unnecessary configuration drift and complicates
  invalidation/instrumentation.

## Pros
- Consistent base URL simplifies client rendering logic and reduces the risk of leaking raw S3 endpoints.
- Single distribution improves cache hit ratios and gives Ops a focused surface for monitoring and invalidations.
- Deterministic path structure makes it easier to trace an object’s provenance (tenant, entity) from logs.
- Shared signing helper reduces implementation errors across services.

## Cons
- Requires re-writing existing metadata that still stores S3 URLs before clients benefit fully from the change.
- Signed URL generation adds slight latency overhead for secure downloads and depends on CloudFront key management hygiene.
- A single distribution concentrates blast radius; misconfiguration affects both public and secure assets simultaneously.

## Operations / Telemetry
- Track CloudFront metrics (cache hit rate, 4xx/5xx error counts, total bytes served) with an alarm when 5xx errors exceed
  baseline thresholds.
- Enable CloudFront access logs to S3 and pipe them into a Kinesis Firehose stream for Athena-based investigations on latency
  outliers or unusual access patterns.
- Add shared-layer instrumentation to increment a custom metric (`SecureUrlGenerationFailures`) whenever signing fails so Ops can
  detect credential drift quickly.
- Integrate CDN request IDs into application logs to tie backend responses to CDN behaviors during incident reviews.

## Implementation Plan
1. Update the shared layer utilities to expose `buildPublicCdnPath` and `signSecureCdnUrl` helpers that embed the CloudFront base.
2. Migrate existing services to store the canonical CDN path in DynamoDB/S3 metadata and backfill historical records where
   feasible.
3. Update frontend download/upload flows to expect `public` vs `secure` paths and request signed URLs when necessary.
4. Configure infrastructure (CloudFront behaviors, origin policies) to map `/public/*` to public S3 origins and `/secure/*`
   to origins requiring Origin Access Control.
5. Document cache invalidation runbooks so Ops understands how to purge stale assets per visibility tier.

## Follow-Up Questions
- Do we need a transitional alias (e.g., `https://files.mylg.app`) for clients that still reference legacy URLs?
- Should we add an automated job to verify that stored CDN paths resolve after deployment (synthetic download test)?
